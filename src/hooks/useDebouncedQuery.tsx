import { useRef } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";

import type { QueryKey, QueryFunction, UseQueryOptions } from "@tanstack/react-query";

/**
 * This is the way we can use the UseQueryOptions so that we maintain the useQuery API
 * and at the same time maintain the types for the return of the queryFn, otherwise the
 * data property would default to unknown.
 */
interface UseDebouncedQueryOptions<TQueryData> extends UseQueryOptions<TQueryData> {
	queryFn: QueryFunction<TQueryData>;
}

export function useDebouncedQuery<TQueryData>(
	{ queryFn, queryKey, ...remainingUseQueryOptions }: UseDebouncedQueryOptions<TQueryData>,
	noRequestReturnFn: () => void,
	debounceMs: number
) {
	const timeoutRef = useRef<number>();
	const queryClient = useQueryClient();
	const previousQueryKeyRef = useRef<QueryKey>();

	return useQuery({
		...remainingUseQueryOptions,
		queryKey,
		queryFn: (queryFnContext) => {
			// This means the react-query is retrying the query, so we should not debounce it.
			if (previousQueryKeyRef.current === queryKey) {
				return queryFn(queryFnContext);
			}

			/**
			 * We need to cancel previous "pending" queries otherwise react-query will give us an infinite
			 * loading state for this key since the Promise we returned was neither resolved nor rejected.
			 */
			if (previousQueryKeyRef.current) {
				void queryClient.cancelQueries({ queryKey: previousQueryKeyRef.current });
			}

			previousQueryKeyRef.current = queryKey;
			window.clearTimeout(timeoutRef.current);

			return new Promise((resolve, reject) => {
				// eslint-disable-next-line @typescript-eslint/no-misused-promises
				timeoutRef.current = window.setTimeout(async () => {
					try {
						if (queryFnContext.queryKey.length) {
							const result = await queryFn(queryFnContext);

							previousQueryKeyRef.current = undefined;
							resolve(result as TQueryData);
						} else {
							/*
							 * tanstack-query hook intialises as soon as component loads but if we don't pass
							 * the initial value it will lead to errors in the console generated by the lib itself.
							 * Other option is to pass an empty value but that would result in query call being triggered,
							 * which is not what we necessarily want. Instead, we check if queryKey data is passed, and if not
							 * we simply return noRequestReturnFn function passed to the hook.
							 * That way we can try to mimic default fetch behaviour with state management where we would expect
							 * that no request is triggered if args have not been passed.
							 */
							resolve(noRequestReturnFn() as TQueryData | PromiseLike<TQueryData>);
						}
					} catch (error) {
						reject(error);
					}
				}, debounceMs);
			});
		},
	});
}
